/*
 * VRChat API Documentation
 *
 *
 * The version of the OpenAPI document: 1.20.3
 * Contact: vrchatapi.lpv0t@aries.fyi
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Reflection;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Text;
using System.Threading;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Polly;

namespace VRChat.API.Client
{
    /// <summary>
    /// Custom JSON serializer that handles the VRChat API specific serialization requirements
    /// </summary>
    internal class CustomJsonCodec
    {
        private readonly IReadableConfiguration _configuration;
        private readonly JsonSerializerSettings _serializerSettings = new JsonSerializerSettings
        {
            // OpenAPI generated types generally hide default constructors.
            ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor,
            ContractResolver = new DefaultContractResolver
            {
                NamingStrategy = new CamelCaseNamingStrategy
                {
                    OverrideSpecifiedNames = false
                }
            }
        };

        public CustomJsonCodec(IReadableConfiguration configuration)
        {
            _configuration = configuration;
        }

        public CustomJsonCodec(JsonSerializerSettings serializerSettings, IReadableConfiguration configuration)
        {
            _serializerSettings = serializerSettings;
            _configuration = configuration;
        }

        /// <summary>
        /// Serialize the object into a JSON string.
        /// </summary>
        /// <param name="obj">Object to be serialized.</param>
        /// <returns>A JSON string.</returns>
        public string Serialize(object obj)
        {
            if (obj != null && obj is VRChat.API.Model.AbstractOpenAPISchema)
            {
                // the object to be serialized is an oneOf/anyOf schema
                return ((VRChat.API.Model.AbstractOpenAPISchema)obj).ToJson();
            }
            else
            {
                return JsonConvert.SerializeObject(obj, _serializerSettings);
            }
        }

        /// <summary>
        /// Deserialize the JSON string into a proper object.
        /// </summary>
        /// <param name="content">The HTTP response content.</param>
        /// <param name="type">Object type.</param>
        /// <param name="headers">Response headers.</param>
        /// <param name="rawBytes">Raw response bytes.</param>
        /// <returns>Object representation of the JSON string.</returns>
        internal object Deserialize(string content, Type type, HttpResponseHeaders headers, byte[] rawBytes)
        {
            if (type == typeof(byte[])) // return byte array
            {
                return rawBytes;
            }

            if (type == typeof(Stream))
            {
                if (headers != null)
                {
                    var filePath = string.IsNullOrEmpty(_configuration.TempFolderPath)
                        ? Path.GetTempPath()
                        : _configuration.TempFolderPath;
                    var regex = new Regex(@"Content-Disposition=.*filename=['""]?([^'""\s]+)['""]?$");
                    foreach (var header in headers)
                    {
                        var match = regex.Match($"{header.Key}={string.Join(",", header.Value)}");
                        if (match.Success)
                        {
                            string fileName = filePath + ClientUtils.SanitizeFilename(match.Groups[1].Value.Replace("\"", "").Replace("'", ""));
                            File.WriteAllBytes(fileName, rawBytes);
                            return new FileStream(fileName, FileMode.Open);
                        }
                    }
                }
                var stream = new MemoryStream(rawBytes);
                return stream;
            }

            if (type.Name.StartsWith("System.Nullable`1[[System.DateTime")) // return a datetime object
            {
                return DateTime.Parse(content, null, System.Globalization.DateTimeStyles.RoundtripKind);
            }

            if (type == typeof(string) || type.Name.StartsWith("System.Nullable")) // return primitive type
            {
                return Convert.ChangeType(content, type);
            }

            // at this point, it must be a model (json)
            try
            {
                return JsonConvert.DeserializeObject(content, type, _serializerSettings);
            }
            catch (Exception e)
            {
                throw new ApiException(500, e.Message);
            }
        }
    }

    /// <summary>
    /// Provides a default implementation of an Api client (both synchronous and asynchronous implementations),
    /// encapsulating general REST accessor use cases.
    /// </summary>
    public partial class ApiClient : ISynchronousClient, IAsynchronousClient
    {
        private readonly string _baseUrl;
        public static readonly CookieContainer CookieContainer = new CookieContainer();
        private readonly HttpClient _httpClient;

        /// <summary>
        /// Specifies the settings on a <see cref="JsonSerializer" /> object.
        /// These settings can be adjusted to accommodate custom serialization rules.
        /// </summary>
        public JsonSerializerSettings SerializerSettings { get; set; } = new JsonSerializerSettings
        {
            // OpenAPI generated types generally hide default constructors.
            ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor,
            ContractResolver = new DefaultContractResolver
            {
                NamingStrategy = new CamelCaseNamingStrategy
                {
                    OverrideSpecifiedNames = false
                }
            }
        };

        /// <summary>
        /// Allows for extending request processing for <see cref="ApiClient"/> generated code.
        /// </summary>
        /// <param name="request">The HttpRequestMessage object</param>
        partial void InterceptRequest(HttpRequestMessage request);

        /// <summary>
        /// Allows for extending response processing for <see cref="ApiClient"/> generated code.
        /// </summary>
        /// <param name="request">The HttpRequestMessage object</param>
        /// <param name="response">The HttpResponseMessage object</param>
        partial void InterceptResponse(HttpRequestMessage request, HttpResponseMessage response);

        /// <summary>
        /// Initializes a new instance of the <see cref="ApiClient" />, defaulting to the global configurations' base url.
        /// </summary>
        public ApiClient()
        {
            _baseUrl = VRChat.API.Client.GlobalConfiguration.Instance.BasePath;
            var handler = new HttpClientHandler()
            {
                CookieContainer = CookieContainer
            };
            _httpClient = new HttpClient(handler);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ApiClient" />
        /// </summary>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <exception cref="ArgumentException"></exception>
        public ApiClient(string basePath)
        {
            if (string.IsNullOrEmpty(basePath))
                throw new ArgumentException("basePath cannot be empty");

            _baseUrl = basePath;
            var handler = new HttpClientHandler()
            {
                CookieContainer = CookieContainer
            };
            _httpClient = new HttpClient(handler);
        }

        /// <summary>
        /// Constructs the HttpMethod from the enum
        /// </summary>
        /// <param name="method">Custom HttpMethod enum</param>
        /// <returns>System.Net.Http.HttpMethod instance.</returns>
        /// <exception cref="ArgumentOutOfRangeException"></exception>
        private System.Net.Http.HttpMethod GetHttpMethod(HttpMethod method)
        {
            switch (method)
            {
                case HttpMethod.Get:
                    return System.Net.Http.HttpMethod.Get;
                case HttpMethod.Post:
                    return System.Net.Http.HttpMethod.Post;
                case HttpMethod.Put:
                    return System.Net.Http.HttpMethod.Put;
                case HttpMethod.Delete:
                    return System.Net.Http.HttpMethod.Delete;
                case HttpMethod.Head:
                    return System.Net.Http.HttpMethod.Head;
                case HttpMethod.Options:
                    return System.Net.Http.HttpMethod.Options;
                case HttpMethod.Patch:
                    return new System.Net.Http.HttpMethod("PATCH");
                default:
                    throw new ArgumentOutOfRangeException("method", method, null);
            }
        }

        /// <summary>
        /// Provides all logic for constructing a new HttpRequestMessage.
        /// At this point, all information for querying the service is known. Here, it is simply
        /// mapped into the HttpRequestMessage.
        /// </summary>
        /// <param name="method">The http verb.</param>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>[private] A new HttpRequestMessage instance.</returns>
        /// <exception cref="ArgumentNullException"></exception>
        private HttpRequestMessage NewRequest(
            HttpMethod method,
            string path,
            RequestOptions options,
            IReadableConfiguration configuration)
        {
            if (path == null) throw new ArgumentNullException("path");
            if (options == null) throw new ArgumentNullException("options");
            if (configuration == null) throw new ArgumentNullException("configuration");

            var baseUrl = configuration.GetOperationServerUrl(options.Operation, options.OperationIndex) ?? _baseUrl;
            
            // Replace path parameters
            var processedPath = path;
            if (options.PathParameters != null)
            {
                foreach (var pathParam in options.PathParameters)
                {
                    processedPath = processedPath.Replace($"{{{pathParam.Key}}}", Uri.EscapeDataString(pathParam.Value.ToString()));
                }
            }

            // Build query string
            var queryString = "";
            if (options.QueryParameters != null && options.QueryParameters.Count > 0)
            {
                var queryParams = new List<string>();
                foreach (var queryParam in options.QueryParameters)
                {
                    foreach (var value in queryParam.Value)
                    {
                        queryParams.Add($"{Uri.EscapeDataString(queryParam.Key)}={Uri.EscapeDataString(value)}");
                    }
                }
                queryString = "?" + string.Join("&", queryParams);
            }

            var requestUri = new Uri($"{baseUrl.TrimEnd('/')}/{processedPath.TrimStart('/')}{queryString}");
            var request = new HttpRequestMessage(GetHttpMethod(method), requestUri);

            // Set default headers
            if (configuration.DefaultHeaders != null)
            {
                foreach (var headerParam in configuration.DefaultHeaders)
                {
                    request.Headers.TryAddWithoutValidation(headerParam.Key, headerParam.Value);
                }
            }

            // Set request headers
            if (options.HeaderParameters != null)
            {
                foreach (var headerParam in options.HeaderParameters)
                {
                    foreach (var value in headerParam.Value)
                    {
                        request.Headers.TryAddWithoutValidation(headerParam.Key, value);
                    }
                }
            }

            // Set User-Agent
            if (!string.IsNullOrEmpty(configuration.UserAgent))
            {
                request.Headers.TryAddWithoutValidation("User-Agent", configuration.UserAgent);
            }

            // Handle request body content
            if (options.FormParameters != null && options.FormParameters.Count > 0)
            {
                var formContent = new List<KeyValuePair<string, string>>();
                foreach (var formParam in options.FormParameters)
                {
                    formContent.Add(new KeyValuePair<string, string>(formParam.Key, formParam.Value.ToString()));
                }
                request.Content = new FormUrlEncodedContent(formContent);
            }
            else if (options.Data != null)
            {
                if (options.Data is Stream stream)
                {
                    var contentType = "application/octet-stream";
                    if (options.HeaderParameters != null && options.HeaderParameters.ContainsKey("Content-Type"))
                    {
                        contentType = options.HeaderParameters["Content-Type"][0];
                    }

                    var bytes = ClientUtils.ReadAsBytes(stream);
                    request.Content = new ByteArrayContent(bytes);
                    request.Content.Headers.TryAddWithoutValidation("Content-Type", contentType);
                }
                else
                {
                    var jsonContent = new CustomJsonCodec(SerializerSettings, configuration).Serialize(options.Data);
                    request.Content = new StringContent(jsonContent, Encoding.UTF8, "application/json");
                }
            }
            else if (options.FileParameters != null && options.FileParameters.Count > 0)
            {
                var multipartContent = new MultipartFormDataContent();
                foreach (var fileParam in options.FileParameters)
                {
                    foreach (var file in fileParam.Value)
                    {
                        var bytes = ClientUtils.ReadAsBytes(file);
                        var fileStream = file as FileStream;
                        var fileName = fileStream != null ? Path.GetFileName(fileStream.Name) : "no_file_name_provided";
                        multipartContent.Add(new ByteArrayContent(bytes), fileParam.Key, fileName);
                    }
                }
                request.Content = multipartContent;
            }

            return request;
        }

        private ApiResponse<T> ToApiResponse<T>(HttpResponseMessage response, string content, byte[] rawBytes)
        {
            var headers = new Multimap<string, string>();

            // Add response headers
            foreach (var header in response.Headers)
            {
                headers.Add(header.Key, string.Join(",", header.Value));
            }

            if (response.Content?.Headers != null)
            {
                foreach (var header in response.Content.Headers)
                {
                    headers.Add(header.Key, string.Join(",", header.Value));
                }
            }

            // Deserialize the response content
            T data = default(T);
            string errorText = !response.IsSuccessStatusCode ? response.ReasonPhrase : null;

            if (typeof(T) != typeof(object) && !string.IsNullOrEmpty(content))
            {
                var codec = new CustomJsonCodec(SerializerSettings, GlobalConfiguration.Instance);
                try
                {
                    // Handle special response types first
                    if (typeof(VRChat.API.Model.AbstractOpenAPISchema).IsAssignableFrom(typeof(T)))
                    {
                        data = (T)typeof(T).GetMethod("FromJson").Invoke(null, new object[] { content });
                    }
                    else if (typeof(T).Name == "Stream") // for binary response
                    {
                        data = (T)(object)new MemoryStream(rawBytes);
                    }
                    else if (typeof(T).Name == "Byte[]") // for byte response
                    {
                        data = (T)(object)rawBytes;
                    }
                    else if (typeof(T).Name == "String") // for string response
                    {
                        data = (T)(object)content;
                    }
                    else
                    {
                        data = (T)codec.Deserialize(content, typeof(T), response.Headers, rawBytes);
                    }
                }
                catch (Exception ex)
                {
                    errorText = ex.Message;
                }
            }

            var transformed = new ApiResponse<T>(response.StatusCode, headers, data, content)
            {
                ErrorText = errorText,
                Cookies = new List<Cookie>()
            };

            return transformed;
        }

        private ApiResponse<T> Exec<T>(HttpRequestMessage req, RequestOptions options, IReadableConfiguration configuration)
        {
            // Configure HttpClient settings
            if (configuration.ClientCertificates != null)
            {
                // Note: Client certificates need to be handled at HttpClientHandler level during construction
                // This is a limitation when reusing HttpClient instances
            }

            if (configuration.Proxy != null)
            {
                // Note: Proxy settings need to be handled at HttpClientHandler level during construction
                // This is a limitation when reusing HttpClient instances
            }

            if (configuration.Timeout > 0)
            {
                _httpClient.Timeout = TimeSpan.FromMilliseconds(configuration.Timeout);
            }

            InterceptRequest(req);

            HttpResponseMessage response;
            if (RetryConfiguration.RetryPolicy != null)
            {
                var policy = RetryConfiguration.RetryPolicy;
                var policyResult = policy.ExecuteAndCapture(() => _httpClient.SendAsync(req).Result);
                response = (policyResult.Outcome == OutcomeType.Successful) ? policyResult.Result : new HttpResponseMessage(HttpStatusCode.InternalServerError);
            }
            else
            {
                response = _httpClient.SendAsync(req).Result;
            }

            var content = response.Content?.ReadAsStringAsync().Result ?? "";
            var rawBytes = response.Content?.ReadAsByteArrayAsync().Result ?? new byte[0];

            InterceptResponse(req, response);

            var result = ToApiResponse<T>(response, content, rawBytes);

            return result;
        }

        private async Task<ApiResponse<T>> ExecAsync<T>(HttpRequestMessage req, RequestOptions options, IReadableConfiguration configuration, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Configure HttpClient settings
            if (configuration.Timeout > 0)
            {
                _httpClient.Timeout = TimeSpan.FromMilliseconds(configuration.Timeout);
            }

            InterceptRequest(req);

            HttpResponseMessage response;
            if (RetryConfiguration.AsyncRetryPolicy != null)
            {
                var policy = RetryConfiguration.AsyncRetryPolicy;
                var policyResult = await policy.ExecuteAndCaptureAsync((ct) => _httpClient.SendAsync(req, ct), cancellationToken).ConfigureAwait(false);
                response = (policyResult.Outcome == OutcomeType.Successful) ? policyResult.Result : new HttpResponseMessage(HttpStatusCode.InternalServerError);
            }
            else
            {
                response = await _httpClient.SendAsync(req, cancellationToken).ConfigureAwait(false);
            }

            var content = response.Content != null ? await response.Content.ReadAsStringAsync().ConfigureAwait(false) : "";
            var rawBytes = response.Content != null ? await response.Content.ReadAsByteArrayAsync().ConfigureAwait(false) : new byte[0];

            InterceptResponse(req, response);

            var result = ToApiResponse<T>(response, content, rawBytes);

            return result;
        }

        #region IAsynchronousClient
        /// <summary>
        /// Make a HTTP GET request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> GetAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Get, path, options, config), options, config, cancellationToken);
        }

        /// <summary>
        /// Make a HTTP POST request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> PostAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Post, path, options, config), options, config, cancellationToken);
        }

        /// <summary>
        /// Make a HTTP PUT request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> PutAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Put, path, options, config), options, config, cancellationToken);
        }

        /// <summary>
        /// Make a HTTP DELETE request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> DeleteAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Delete, path, options, config), options, config, cancellationToken);
        }

        /// <summary>
        /// Make a HTTP HEAD request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> HeadAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Head, path, options, config), options, config, cancellationToken);
        }

        /// <summary>
        /// Make a HTTP OPTION request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> OptionsAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Options, path, options, config), options, config, cancellationToken);
        }

        /// <summary>
        /// Make a HTTP PATCH request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> PatchAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return ExecAsync<T>(NewRequest(HttpMethod.Patch, path, options, config), options, config, cancellationToken);
        }
        #endregion IAsynchronousClient

        #region ISynchronousClient
        /// <summary>
        /// Make a HTTP GET request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Get<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Get, path, options, config), options, config);
        }

        /// <summary>
        /// Make a HTTP POST request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Post<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Post, path, options, config), options, config);
        }

        /// <summary>
        /// Make a HTTP PUT request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Put<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Put, path, options, config), options, config);
        }

        /// <summary>
        /// Make a HTTP DELETE request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Delete<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Delete, path, options, config), options, config);
        }

        /// <summary>
        /// Make a HTTP HEAD request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Head<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Head, path, options, config), options, config);
        }

        /// <summary>
        /// Make a HTTP OPTION request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Options<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Options, path, options, config), options, config);
        }

        /// <summary>
        /// Make a HTTP PATCH request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
        /// GlobalConfiguration has been done before calling this method.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Patch<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
        {
            var config = configuration ?? GlobalConfiguration.Instance;
            return Exec<T>(NewRequest(HttpMethod.Patch, path, options, config), options, config);
        }
        #endregion ISynchronousClient

        #region IDisposable
        public void Dispose()
        {
            _httpClient?.Dispose();
        }
        #endregion
    }
}
